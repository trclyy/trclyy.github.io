<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>田润超的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-13T02:51:16.718Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>田润超</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>正则表达式的使用</title>
    <link href="http://yoursite.com/2018/12/12/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/12/12/正则表达式的使用/</id>
    <published>2018-12-12T12:21:16.000Z</published>
    <updated>2018-12-13T02:51:16.718Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>正则表达式在爬虫中被广泛使用，正则和Xpath各有各的优点。虽然以前学习过正则表达式，但现在还总是迷迷糊糊的，今天有所顿悟。</p><h2 id="re-search-和re-match"><a href="#re-search-和re-match" class="headerlink" title="re.search()和re.match()"></a>re.search()和re.match()</h2><p>re.match决定RE是否在字符串刚开始的位置匹配。//注：这个方法并不是完全匹配。当pattern结束时若string还有剩余字符，仍然视为成功。想要完全匹配，可以在表达式末尾加上边界匹配符’$’</p><p>re.search函数会在字符串内查找模式匹配,只要找到第一个匹配然后返回，如果字符串没有匹配，则返回None。</p><p>match和search一旦匹配成功，就是一个match object对象，而match object对象有以下方法：</p><ul><li>group() 返回被RE匹配的字符串</li><li>start() 返回匹配开始的位置编号</li><li>end() 返回匹配结束的位置编号</li><li>span() 返回一个元组包含匹配（开始，结束）的位置编号</li><li>group() 返回re整体匹配的字符串，可以一次输入多个组号，对应组号匹配的字符串</li></ul><p>re.search()后使用group()不加参数表示返回被匹配的整体字符串，group()加上一个参数1表示取出匹配的第一组字符，可以输入多个组号。</p><p>eg.:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">str1 = <span class="string">'&lt;h1&gt;hello world&lt;/h1&gt;你好世界&lt;/h1&gt;'</span></span><br><span class="line">x = re.search(<span class="string">'&lt;h1&gt;(.*?)&lt;/h1&gt;(.*?)&lt;/h1&gt;'</span>, str1).group(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">print(x)</span><br><span class="line">结果：(<span class="string">'hello world'</span>, <span class="string">'你好世界'</span>)</span><br></pre></td></tr></table></figure><h2 id="re-compile和re-findall"><a href="#re-compile和re-findall" class="headerlink" title="re.compile和re.findall"></a>re.compile和re.findall</h2><p>re.compile是对正则表达式进行预编译，返回一个对象的模式，主要作用是把常用的正则表达式编译成正则表达式对象，这样可以提高一点效率。</p><p>格式：<code>re.compile(pattern,flags=0)</code></p><p>pattern：编译时用的表达式字符串</p><p>flags：编译标志位，用于修改正则表达式的匹配方式，模式修正符。</p><p>常用的flags模式修正符有：</p><ul><li>re.S：使.匹配包括换行符在内的所有字符</li><li>re.I：使匹配不区分大小写</li><li>re.L：做本地化识别匹配</li><li>re.M：多行匹配，影响^和$</li><li>re.X：该标志通过给予更灵活的格式一遍将正则表达式写的更易于理解</li><li>re.U：根据Unicode字符集解析字符，这个标志影响\w,\W,\b,\B</li></ul><p>re.findall遍历匹配，可以获取字符串中所有匹配的字符串，返回一个列表。</p><p>格式：re.findall(pattern, string, flags=0)</p><p>pattern为表达式字符串，</p><p>strings为要匹配的字符串</p><p>flags为模式修正符</p><p>所以可以看到：</p><p>在findall中包含了compile，为了简洁，一般我都不适用compile。</p><h2 id="re-finditer"><a href="#re-finditer" class="headerlink" title="re.finditer"></a>re.finditer</h2><p>re.finditer() 搜索string，返回一个顺序访问每一个匹配结果（Match对象）的迭代器。找到 RE 匹配的所有子串，并把它们作为一个迭代器返回。</p><p>格式和findall()一样，返回的是一个迭代器，要使用for循环迭代取值，由于他返回的是一个Match对象，所以还要使用.group()函数来取出字符串。</p><h2 id="re-split"><a href="#re-split" class="headerlink" title="re.split"></a>re.split</h2><p>按照能够匹配的子串将string分割后返回列表。</p><p>可以使用re.split来分割字符串，如：re.split(r’\s+’, text)；将字符串按空格分割成一个单词列表。</p><p>格式：</p><p>re.split(pattern, string[, maxsplit])</p><p>maxsplit用于指定最大分割次数，不指定将全部分割。</p><p>eg.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(re.split(<span class="string">'\d+'</span>,<span class="string">'one1two2three3four4five5'</span>))</span><br><span class="line">执行结果如下：</span><br><span class="line">[<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>, <span class="string">'five'</span>, <span class="string">''</span>]</span><br></pre></td></tr></table></figure><h2 id="re-sup"><a href="#re-sup" class="headerlink" title="re.sup"></a>re.sup</h2><p>re.sup使用re替换string中每一个匹配的子串后返回替换后的字符串。</p><p>eg.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.sup(&apos;[\n ]&apos;, &apos;&apos;, str)</span><br></pre></td></tr></table></figure><p>上面这个例子会吧str中所有的换行符和空格去除。</p><h2 id="一些要注意的地方"><a href="#一些要注意的地方" class="headerlink" title="一些要注意的地方"></a>一些要注意的地方</h2><p><strong>re.match与re.search与re.findall的区别：</strong></p><p>re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a=re.search(<span class="string">'[\d]'</span>,<span class="string">"abc33"</span>).group()</span><br><span class="line">print(a)</span><br><span class="line">p=re.match(<span class="string">'[\d]'</span>,<span class="string">"abc33"</span>)</span><br><span class="line">print(p)</span><br><span class="line">b=re.findall(<span class="string">'[\d]'</span>,<span class="string">"abc33"</span>)</span><br><span class="line">print(b)</span><br><span class="line">执行结果：</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="keyword">None</span></span><br><span class="line">[<span class="string">'3'</span>, <span class="string">'3'</span>]</span><br></pre></td></tr></table></figure><p><strong>贪婪匹配与非贪婪匹配</strong></p><p><em>?,+?,??,{m,n}?    前面的</em>,+,?等都是贪婪匹配，也就是尽可能匹配，后面加?号使其变成惰性匹配</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">a = re.findall(<span class="string">r"a(\d+?)"</span>,<span class="string">'a23b'</span>)</span><br><span class="line">print(a)</span><br><span class="line">b = re.findall(<span class="string">r"a(\d+)"</span>,<span class="string">'a23b'</span>)</span><br><span class="line">print(b)</span><br><span class="line">执行结果：</span><br><span class="line">[<span class="string">'2'</span>]</span><br><span class="line">[<span class="string">'23'</span>]</span><br><span class="line"></span><br><span class="line">a = re.match(<span class="string">'&lt;(.*)&gt;'</span>,<span class="string">'&lt;H1&gt;title&lt;H1&gt;'</span>).group()</span><br><span class="line">print(a)</span><br><span class="line">b = re.match(<span class="string">'&lt;(.*?)&gt;'</span>,<span class="string">'&lt;H1&gt;title&lt;H1&gt;'</span>).group()</span><br><span class="line">print(b)</span><br><span class="line">执行结果：</span><br><span class="line">&lt;H1&gt;title&lt;H1&gt;</span><br><span class="line">&lt;H1&gt;</span><br><span class="line"></span><br><span class="line">a = re.findall(<span class="string">r"a(\d+)b"</span>,<span class="string">'a3333b'</span>)</span><br><span class="line">print(a)</span><br><span class="line">b = re.findall(<span class="string">r"a(\d+?)b"</span>,<span class="string">'a3333b'</span>)</span><br><span class="line">print(b)</span><br><span class="line">执行结果如下：</span><br><span class="line">[<span class="string">'3333'</span>]</span><br><span class="line">[<span class="string">'3333'</span>]</span><br><span class="line"><span class="comment">#######################</span></span><br><span class="line">这里需要注意的是如果前后均有限定条件的时候，就不存在什么贪婪模式了，非匹配模式失效。</span><br></pre></td></tr></table></figure><p>本篇博客借鉴<a href="https://www.cnblogs.com/tina-python/p/5508402.html" target="_blank" rel="noopener">CNBLOGS</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;正则表达式&lt;/h1&gt;&lt;p&gt;正则表达式在爬虫中被广泛使用，正则和Xpath各有各的优点。虽然以前学习过正则表达式，但现在还总是迷迷糊糊的，今天有
      
    
    </summary>
    
      <category term="爬虫" scheme="http://yoursite.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
</feed>
